<div id="abstract" class="form-section hidden">
    <form onsubmit="return false" id="submitAbstractForm">
    <div>
      <input type="text" id="abstract_value" value="<%= SavedAbstract%>" readonly hidden>
      <h3 class="manu_head"><span style="color: #e22424;">*</span>Abstract</h3><br>
      <input type="text" name="manuscript_id" value="<%=article_id%>" readonly hidden>

      <!-- Quill container - make sure this is unique -->
      <div id="abstract-quill-container">
        <div class="bg-body border rounded-bottom h-400px overflow-hidden" id="quilleditor" style="height: 500px;">
        </div>
      </div>
      <div id="word-count" class="wordCount"></div><span id="limit-exceed"> </span>
    </div>
    <p style="color: #e22424;">* Indicates Mandatory Fields</p> <br>

    <div style="display: flex; justify-content: space-around;">
      <!-- back button  -->
      <button type="button" class="submit-next" onclick="NavigationNext('title', 'title_nav', 'abstract_nav', 2)">Back</button>
      <!-- end back button  -->
      <input type="submit" value="submit" id="submitAbstract" disabled hidden>
      <!-- next button  -->
      <button type="button" class="submit-next nextManuscript" onclick="submitSection('submitAbstract')" >Save & Continue</button>
      <!-- end next button  -->
    </div>
    </form>
  </div>

  <script type="module">
    import { getQuillInstance, isQuillInitialized, destroyQuillInstances } from '/js/quill.js';
    
    let abstractQuill = null;
    let abstractInitialized = false;

    function initializeAbstractQuill() {
      if (abstractInitialized) return abstractQuill;
      
      const abstract_value = document.getElementById("abstract_value");
      const savedAbstract = abstract_value?.value || '';
      
      // Parse the abstract content
      let parsedAbstract = { ops: [{ insert: "\n" }] };
      
      if (savedAbstract && savedAbstract !== 'null' && savedAbstract !== 'undefined') {
        try {
          // Clean the string
          function prepareJSON(str) {
            if (!str) return '{"ops":[{"insert":"\\n"}]}';
            
            const decoded = str.replace(/&[#\w]+;/g, m => 
              new DOMParser().parseFromString(m, "text/html").body.textContent
            );
            
            return decoded
              .trim()
              .replace(/([\w"])\s*$/, '$1')
              .replace(/^([^[{])/, '')
              .replace(/([^\]}])$/, '');
          }

          const cleanJSON = prepareJSON(savedAbstract);
          parsedAbstract = JSON.parse(cleanJSON);
          
          if (Array.isArray(parsedAbstract)) {
            parsedAbstract = { ops: parsedAbstract };
          } else if (!parsedAbstract.ops) {
            parsedAbstract = { ops: [{ insert: "\n" }] };
          }
        } catch (error) {
          console.error("Abstract parsing error:", error);
          parsedAbstract = { ops: [{ insert: "\n" }] };
        }
      }

      // Initialize Quill with the parsed content
      abstractQuill = getQuillInstance('#quilleditor', parsedAbstract);
      abstractInitialized = true;
      
      return abstractQuill;
    }

    // Initialize when abstract section becomes visible
    function handleAbstractSectionVisibility() {
      const abstractSection = document.getElementById('abstract');
      if (abstractSection && !abstractSection.classList.contains('hidden')) {
        if (!abstractInitialized) {
          setTimeout(() => {
            initializeAbstractQuill();
          }, 100);
        }
      }
    }

    // Observe section visibility changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'class') {
          handleAbstractSectionVisibility();
        }
      });
    });

    const abstractSection = document.getElementById('abstract');
    if (abstractSection) {
      observer.observe(abstractSection, { attributes: true });
    }

    // Form submission handler
    const submitAbstractForm = document.getElementById("submitAbstractForm");
    if (submitAbstractForm) {
      submitAbstractForm.addEventListener("submit", function(e){
        e.preventDefault();
        
        if (!abstractQuill) {
          showErrorPopup("Editor not ready. Please wait...");
          return;
        }

        const data = {
          abstract: JSON.stringify(abstractQuill.getContents().ops)
        };
       const currentSubmissionProcess = "<%= currentSubmissionProcess %>";
  const queriedID = "<%= queriedID %>";
        fetch(`/submitAbstract?_uid=${uid.value}&prg=true&${queriedID}&${currentSubmissionProcess}=true`, {
          method: "POST",
          headers: {
            "Content-type": "application/json"
          },
          body: JSON.stringify(data)
        })
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            iziToast.error({
              message: data.error,
              position: "topRight"
            });
          } else if (data.success) {
            showProgressSavedPopup();
            showNext('keywords', 'abstract', 'abstract_nav', 'keywords_nav', 'title', 4, 4, 'submitAbstract');
          } else {
            showErrorPopup("An Error Occurred. Please try again");
          }
        })
        .catch(error => {
          console.error("Submission error:", error);
          showErrorPopup("Network error. Please check your connection.");
        });
      });
    }

    // Cleanup when leaving the page
    window.addEventListener('beforeunload', function() {
      if (abstractInitialized) {
        destroyQuillInstances();
      }
    });
  </script>